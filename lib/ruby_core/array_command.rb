require_relative "../types/types/array_type.rb"
require_relative "../ast/interpreter.rb"

module Ikra
    module RubyIntegration

        # This visitor traverses the tree of symbolically executed parallel operations. It raises
        # an exception, if an array command was generated by symbolic execution/interpretation of
        # `send_node`.
        class SymbolicCycleFinder < Symbolic::Visitor
            def self.raise_on_cycle(command, send_node)
                visitor = self.new(send_node)
                command.accept(visitor)
            end

            def initialize(send_node)
                @send_node = send_node
            end

            def visit_array_command(node)
                if node.generator_node == @send_node
                    raise CycleDetectedError.new(node: node)
                else
                    # No cycle found yet, check dependent computations
                    super
                end
            end
        end

        class CycleDetectedError < RuntimeError
            def initialize(node:)
                @node = node
            end
        end

        ALL_ARRAY_COMMAND_TYPES = proc do |type|
            type.is_a?(Symbolic::ArrayCommand)
        end

        MAP_TYPE = proc do |rcvr_type, *args_types, send_node:|
            # TODO: Handle keyword arguments
            
            # Ensure that there is no cycle here. "Cycle" means that the same AST send node
            # was used earlier (i.e., in one of `rcvr_type`'s inputs/dependent computations).
            # In that case we have to abort type inference here, because it would not terminate.
            SymbolicCycleFinder.raise_on_cycle(rcvr_type, send_node)

            more_kw_args = {}

            if send_node.arguments.size == 1
                if !send_node.arguments.first.is_a?(AST::HashNode)
                    raise ArgumentError.new("If an argument is given, it must be a Hash of kwargs.")
                end

                # Pass kwargs separately
                more_kw_args = AST::Interpreter.interpret(send_node.arguments.first)
            end

            rcvr_type.map(
                ast: send_node.block_argument, 
                generator_node: send_node, 
                # TODO: Fix binding
                command_binding: send_node.find_behavior_node.binding,
                **more_kw_args).to_union_type
        end

        ZIP_TYPE = proc do |rcvr_type, *args_types, send_node:|
            # TODO: Support multiple arguments for `zip`
            types = args_types[0].map do |sing_type|
                raise AssertionError.new("Singleton type expected") if sing_type.is_union_type?
                rcvr_type.zip(sing_type, generator_node: send_node).to_union_type
            end

            types.reduce(Types::UnionType.new) do |acc, type|
                acc.expand_return_type(type)
            end
        end

        STENCIL_TYPE = proc do |rcvr_type, *args_types, send_node:|
            # TODO: Handle keyword arguments
            ruby_args = send_node.arguments.map do |node|
                AST::Interpreter.interpret(node)
            end

            more_kw_args = {}

            if args_types.size == 3
                if !ruby_args.last.is_a?(Hash)
                    raise ArgumentError.new("If 3 arguments are given, the last one must be a Hash of kwargs.")
                end

                # Pass kwargs separately
                more_kw_args = ruby_args.pop
            end

            SymbolicCycleFinder.raise_on_cycle(rcvr_type, send_node)

            rcvr_type.stencil(
                *ruby_args, 
                ast: send_node.block_argument, 
                generator_node: send_node, 
                # TODO: Fix binding
                command_binding: send_node.find_behavior_node.binding,
                **more_kw_args).to_union_type
        end

        REDUCE_TYPE = proc do |rcvr_type, *args_types, send_node:|
            # TODO: Handle keyword arguments
            
            SymbolicCycleFinder.raise_on_cycle(rcvr_type, send_node)

            rcvr_type.reduce(ast: send_node.block_argument, generator_node: send_node).to_union_type
        end

        LAUNCH_KERNEL = proc do |receiver, method_name, arguments, translator, result_type|
            # The result type is the symbolically executed result of applying this
            # parallel section. The result type is an ArrayCommand.
            array_command = receiver.get_type.singleton_type

            # Translate command
            command_translator = translator.command_translator
            command_translator.push_kernel_launcher
            result = array_command.accept(command_translator)
            kernel_launcher = command_translator.pop_kernel_launcher(result)

            # Prepare kernel launchers for launch of `array_command`
            command_translator.program_builder.prepare_additional_args_for_launch(array_command)

            # Generate launch code for all kernels
            launch_code = command_translator.program_builder.build_kernel_launchers

            # Always return a device pointer. Only at the very end, we transfer data to the host.
            result_expr = kernel_launcher.kernel_result_var_name

            if Translator::ArrayCommandStructBuilder::RequireRuntimeSizeChecker.require_size_function?(array_command)

                # Size is not statically known, take information from receiver.
                # TODO: Code depends on template. `cmd` is defined in template.
                result_size = "cmd->size()"
            else
                # Size is known statically
                result_size = array_command.size.to_s
            end
                    
            # Debug information
            if array_command.generator_node != nil
                debug_information = array_command.to_s + ": " + array_command.generator_node.to_s
            else
                debug_information = array_command.to_s
            end

            result = Translator.read_file(file_name: "host_section_launch_parallel_section.cpp", replacements: {
                "debug_information" => debug_information, 
                "array_command" => receiver.accept(translator.expression_translator),
                "array_command_type" => array_command.to_c_type,
                "result_size" => result_size,
                "kernel_invocation" => launch_code,
                "kernel_result" => result_expr,
                "free_memory" => command_translator.program_builder.build_memory_free_except_last})

            # Clear kernel launchers. Otherwise, we might launch them again in a later, unrelated
            # LAUNCH_KERNEL branch. This is because we reuse the same [ProgramBuilder] for an
            # entire host section.
            command_translator.program_builder.clear_kernel_launchers

            # Build all array command structs for this command
            command_translator.program_builder.add_array_command_struct(
                *Translator::ArrayCommandStructBuilder.build_all_structs(array_command))

            result
        end

        ARRAY_COMMAND_TO_ARRAY_TYPE = proc do |rcvr_type, *args_types, send_node:|
            Types::LocationAwareFixedSizeArrayType.new(
                rcvr_type.result_type,
                rcvr_type.dimensions,
                location: :device).to_union_type
        end

        SYMBOLICALLY_EXECUTE_KERNEL = proc do |receiver, method_name, arguments, translator, result_type|
            if !result_type.is_singleton?
                raise AssertionError.new("Singleton type expected")
            end

            # Build arguments to constructor. First one (result field) is NULL.
            constructor_args = ["NULL"]

            # Translate all inputs (receiver, then arguments to parallel section)
            constructor_args.push(receiver.accept(translator.expression_translator))

            for arg in arguments
                if arg.get_type.is_singleton? && 
                    arg.get_type.singleton_type.is_a?(Symbolic::ArrayCommand)
                    
                    # Only ArrayCommands should show up as arguments
                    constructor_args.push(arg.accept(translator.expression_translator))
                end
            end

            all_args = constructor_args.join(", ")

            # This is a hack because the type is a pointer type
            "new #{result_type.singleton_type.to_c_type[0...-2]}(#{all_args})"
        end

        ALL_LOCATION_AWARE_ARRAY_TYPES = proc do |type|
            type.is_a?(Types::LocationAwareArrayType)
        end

        LOCATION_AWARE_ARRAY_TO_HOST_ARRAY_TYPE = proc do |rcvr_type, *args_types|
            # TODO: Should also be able to handle variable variant
            Types::LocationAwareFixedSizeArrayType.new(
                rcvr_type.inner_type,
                rcvr_type.dimensions,
                location: :host).to_union_type
        end

        LOCATION_AWARE_ARRAY_CALL_TYPE = proc do |rcvr_type, *args_types|
            # Calling `__call__` on an array does not do anything
            rcvr_type.to_union_type
        end

        COPY_ARRAY_TO_HOST = proc do |receiver, method_name, args, translator, result_type|
            if receiver.get_type.singleton_type.location == :host
                receiver.accept(translator.expression_translator)
            else
                c_type = receiver.get_type.singleton_type.inner_type.to_c_type

                Translator.read_file(file_name: "memcpy_device_to_host_expr.cpp", replacements: {
                    "type" => c_type,
                    "device_array" => receiver.accept(translator.expression_translator)})
            end
        end

        ARRAY_TYPE_TO_PA_TYPE = proc do |rcvr_type, *args_types, send_node:|
            rcvr_type.to_pa.to_union_type
        end

        FREE_MEMORY_FOR_ARRAY_COMMAND = proc do |receiver, method_name, args, translator, result_type|

            Translator.read_file(file_name: "free_memory_for_command.cpp", replacements: {
                "type" => receiver.get_type.to_c_type,
                "receiver" => receiver.accept(translator.expression_translator)})
        end

        # Manually free memory
        # TODO: Implement escape analysis and try to reuse memory
        implement(
            ALL_ARRAY_COMMAND_TYPES,
            :free_memory,
            BOOL,
            0,
            FREE_MEMORY_FOR_ARRAY_COMMAND)

        # Implement all parallel operations
        implement(
            ALL_ARRAY_COMMAND_TYPES,
            :map,
            MAP_TYPE,
            0..1,
            SYMBOLICALLY_EXECUTE_KERNEL)

        implement(
            ALL_LOCATION_AWARE_ARRAY_TYPES,
            :to_pa,
            ARRAY_TYPE_TO_PA_TYPE,
            0,
            SYMBOLICALLY_EXECUTE_KERNEL)

        implement(
            ALL_ARRAY_COMMAND_TYPES,
            :zip,
            ZIP_TYPE,
            1,
            SYMBOLICALLY_EXECUTE_KERNEL,
            expect_singleton_args: true)

        implement(
            ALL_ARRAY_COMMAND_TYPES,
            :stencil,
            STENCIL_TYPE,
            2..3,      # neighborhood and default value, maybe hash
            SYMBOLICALLY_EXECUTE_KERNEL)

        implement(
            ALL_ARRAY_COMMAND_TYPES,
            :reduce,
            REDUCE_TYPE,
            0,
            SYMBOLICALLY_EXECUTE_KERNEL)

        implement(
            ALL_ARRAY_COMMAND_TYPES,
            :__call__,
            ARRAY_COMMAND_TO_ARRAY_TYPE,
            0,
            LAUNCH_KERNEL)

        implement(
            ALL_LOCATION_AWARE_ARRAY_TYPES, 
            :__to_host_array__,
            LOCATION_AWARE_ARRAY_TO_HOST_ARRAY_TYPE,
            0,
            COPY_ARRAY_TO_HOST)

        implement(
            ALL_LOCATION_AWARE_ARRAY_TYPES,
            :__call__,
            LOCATION_AWARE_ARRAY_CALL_TYPE,
            0,
            "#0")
    end
end
